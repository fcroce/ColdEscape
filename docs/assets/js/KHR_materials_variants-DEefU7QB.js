import{G as S,A as V}from"./glTFLoader-B7_AMTvd.js";import{M as C,a6 as I,a7 as O}from"./index-BKX_SAiS.js";import"./glTFLoaderAnimation-DQnBhtdO.js";const n="KHR_materials_variants";class d{constructor(t){this.name=n,this._loader=t,this.enabled=this._loader.isExtensionUsed(n)}dispose(){this._loader=null}static GetAvailableVariants(t){const a=this._GetExtensionMetadata(t);return a?Object.keys(a.variants):[]}getAvailableVariants(t){return d.GetAvailableVariants(t)}static SelectVariant(t,a){const i=this._GetExtensionMetadata(t);if(!i)throw new Error(`Cannot select variant on a glTF mesh that does not have the ${n} extension`);const f=c=>{const h=i.variants[c];if(h)for(const m of h)m.mesh.material=m.material};if(a instanceof Array)for(const c of a)f(c);else f(a);i.lastSelected=a}selectVariant(t,a){d.SelectVariant(t,a)}static Reset(t){const a=this._GetExtensionMetadata(t);if(!a)throw new Error(`Cannot reset on a glTF mesh that does not have the ${n} extension`);for(const i of a.original)i.mesh.material=i.material;a.lastSelected=null}reset(t){d.Reset(t)}static GetLastSelectedVariant(t){const a=this._GetExtensionMetadata(t);if(!a)throw new Error(`Cannot get the last selected variant on a glTF mesh that does not have the ${n} extension`);return a.lastSelected}getLastSelectedVariant(t){return d.GetLastSelectedVariant(t)}static _GetExtensionMetadata(t){var a,i;return((i=(a=t==null?void 0:t._internalMetadata)==null?void 0:a.gltf)==null?void 0:i[n])||null}onLoading(){const t=this._loader.gltf.extensions;if(t&&t[this.name]){const a=t[this.name];this._variants=a.variants}}_loadMeshPrimitiveAsync(t,a,i,f,c,h){return S.LoadExtensionAsync(t,c,this.name,(m,G)=>{const v=new Array;return v.push(this._loader._loadMeshPrimitiveAsync(t,a,i,f,c,r=>{if(h(r),r instanceof C){const $=S._GetDrawMode(t,c.mode),l=this._loader.rootBabylonMesh,E=l?l._internalMetadata=l._internalMetadata||{}:{},w=E.gltf=E.gltf||{},g=w[n]=w[n]||{lastSelected:null,original:[],variants:{}};g.original.push({mesh:r,material:r.material});for(let p=0;p<G.mappings.length;++p){const u=G.mappings[p],F=V.Get(`${m}/mappings/${p}/material`,this._loader.gltf.materials,u.material);v.push(this._loader._loadMaterialAsync(`#/materials/${u.material}`,F,r,$,T=>{for(let x=0;x<u.variants.length;++x){const A=u.variants[x],M=V.Get(`/extensions/${n}/variants/${A}`,this._variants,A);g.variants[M.name]=g.variants[M.name]||[],g.variants[M.name].push({mesh:r,material:T}),r.onClonedObservable.add(k=>{const _=k;let o=null,s=_;do{if(s=s.parent,!s)return;o=d._GetExtensionMetadata(s)}while(o===null);if(l&&o===d._GetExtensionMetadata(l)){s._internalMetadata={};for(const e in l._internalMetadata)s._internalMetadata[e]=l._internalMetadata[e];s._internalMetadata.gltf=[];for(const e in l._internalMetadata.gltf)s._internalMetadata.gltf[e]=l._internalMetadata.gltf[e];s._internalMetadata.gltf[n]={lastSelected:null,original:[],variants:{}};for(const e of o.original)s._internalMetadata.gltf[n].original.push({mesh:e.mesh,material:e.material});for(const e in o.variants)if(Object.prototype.hasOwnProperty.call(o.variants,e)){s._internalMetadata.gltf[n].variants[e]=[];for(const y of o.variants[e])s._internalMetadata.gltf[n].variants[e].push({mesh:y.mesh,material:y.material})}o=s._internalMetadata.gltf[n]}for(const e of o.original)e.mesh===r&&(e.mesh=_);for(const e of o.variants[M.name])e.mesh===r&&(e.mesh=_)})}}))}}})),Promise.all(v).then(([r])=>r)})}}I(n);O(n,!0,L=>new d(L));export{d as KHR_materials_variants};
