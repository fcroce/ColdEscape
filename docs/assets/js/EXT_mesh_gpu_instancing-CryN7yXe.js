import{a8 as e,b as y,a3 as T,a4 as F,a6 as b,a7 as E}from"./index-Curn0qvy.js";import{G as M,A as V}from"./glTFLoader-By7KYH5z.js";import"./glTFLoaderAnimation-CuW2wpvm.js";const n="EXT_mesh_gpu_instancing";class g{constructor(i){this.name=n,this._loader=i,this.enabled=this._loader.isExtensionUsed(n)}dispose(){this._loader=null}loadNodeAsync(i,t,f){return M.LoadExtensionAsync(i,t,this.name,(m,h)=>{this._loader._disableInstancedMesh++;const d=this._loader.loadNodeAsync(`/nodes/${t.index}`,t,f);if(this._loader._disableInstancedMesh--,!t._primitiveBabylonMeshes)return d;const c=new Array;let o=0;const l=a=>{if(h.attributes[a]==null){c.push(Promise.resolve(null));return}const s=V.Get(`${m}/attributes/${a}`,this._loader.gltf.accessors,h.attributes[a]);if(c.push(this._loader._loadFloatAccessorAsync(`/accessors/${s.bufferView}`,s)),o===0)o=s.count;else if(o!==s.count)throw new Error(`${m}/attributes: Instance buffer accessors do not have the same count.`)};return l("TRANSLATION"),l("ROTATION"),l("SCALE"),d.then(a=>Promise.all(c).then(([s,p,A])=>{const _=new Float32Array(o*16);e.Vector3[0].copyFromFloats(0,0,0),e.Quaternion[0].copyFromFloats(0,0,0,1),e.Vector3[1].copyFromFloats(1,1,1);for(let r=0;r<o;++r)s&&y.FromArrayToRef(s,r*3,e.Vector3[0]),p&&T.FromArrayToRef(p,r*4,e.Quaternion[0]),A&&y.FromArrayToRef(A,r*3,e.Vector3[1]),F.ComposeToRef(e.Vector3[1],e.Quaternion[0],e.Vector3[0],e.Matrix[0]),e.Matrix[0].copyToArray(_,r*16);for(const r of t._primitiveBabylonMeshes)r.thinInstanceSetBuffer("matrix",_,16,!0);return a}))})}}b(n);E(n,!0,u=>new g(u));export{g as EXT_mesh_gpu_instancing};
