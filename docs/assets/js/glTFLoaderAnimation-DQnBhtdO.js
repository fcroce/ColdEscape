import{aa as m,b as h,a3 as p}from"./index-BKX_SAiS.js";function A(i,n,t,e){return h.FromArray(n,t).scaleInPlace(e)}function f(i,n,t,e){return p.FromArray(n,t).scaleInPlace(e)}function b(i,n,t,e){const a=new Array(i._numMorphTargets);for(let r=0;r<a.length;r++)a[r]=n[t++]*e;return a}class c{constructor(n,t,e,a){this.type=n,this.name=t,this.getValue=e,this.getStride=a}_buildAnimation(n,t,e){const a=new m(n,this.name,t,this.type);return a.setKeys(e),a}}class l extends c{buildAnimations(n,t,e,a,r){r(n._babylonTransformNode,this._buildAnimation(t,e,a))}}class _ extends c{buildAnimations(n,t,e,a,r){if(n._numMorphTargets)for(let s=0;s<n._numMorphTargets;s++){const u=new m(`${t}_${s}`,this.name,e,this.type);if(u.setKeys(a.map(o=>({frame:o.frame,inTangent:o.inTangent?o.inTangent[s]:void 0,value:o.value[s],outTangent:o.outTangent?o.outTangent[s]:void 0,interpolation:o.interpolation}))),n._primitiveBabylonMeshes){for(const o of n._primitiveBabylonMeshes)if(o.morphTargetManager){const T=o.morphTargetManager.getTarget(s),g=u.clone();T.animations.push(g),r(T,g)}}}}}const I={translation:[new l(m.ANIMATIONTYPE_VECTOR3,"position",A,()=>3)],rotation:[new l(m.ANIMATIONTYPE_QUATERNION,"rotationQuaternion",f,()=>4)],scale:[new l(m.ANIMATIONTYPE_VECTOR3,"scaling",A,()=>3)],weights:[new _(m.ANIMATIONTYPE_FLOAT,"influence",b,i=>i._numMorphTargets)]};export{c as A,I as n};
