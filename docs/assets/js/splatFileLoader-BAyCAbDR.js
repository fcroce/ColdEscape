import{f as b,M as N,d as W,P as L,g as S,A as R,L as T,r as j,b as $,a as q}from"./index-ySfS2gYj.js";var B;(function(y){y[y.Splat=0]="Splat",y[y.PointCloud=1]="PointCloud",y[y.Mesh=2]="Mesh"})(B||(B={}));class w{constructor(n=w._DefaultLoadingOptions){this.name=b.name,this._assetContainer=null,this.extensions=b.extensions,this._loadingOptions=n}createPlugin(n){return new w(n[b.name])}async importMeshAsync(n,s,e,r,t,a){return this._parse(n,s,e,r).then(o=>({meshes:o,particleSystems:[],skeletons:[],animationGroups:[],transformNodes:[],geometries:[],lights:[],spriteManagers:[]}))}static _BuildPointCloud(n,s){if(!s.byteLength)return!1;const e=new Uint8Array(s),r=new Float32Array(s),t=3*4+3*4+4+4,a=e.length/t,o=function(h,l){const i=r[8*l+0],c=r[8*l+1],m=r[8*l+2];h.position=new $(i,c,m);const d=e[t*l+24+0]/255,C=e[t*l+24+1]/255,g=e[t*l+24+2]/255;h.color=new q(d,C,g,1)};return n.addPoints(a,o),!0}static _BuildMesh(n,s){const e=new N("PLYMesh",n),r=new Uint8Array(s.data),t=new Float32Array(s.data),a=3*4+3*4+4+4,o=r.length/a,h=[],l=new W;for(let i=0;i<o;i++){const c=t[8*i+0],m=t[8*i+1],d=t[8*i+2];h.push(c,m,d)}if(s.hasVertexColors){const i=new Float32Array(o*4);for(let c=0;c<o;c++){const m=r[a*c+24+0]/255,d=r[a*c+24+1]/255,C=r[a*c+24+2]/255;i[c*4+0]=m,i[c*4+1]=d,i[c*4+2]=C,i[c*4+3]=1}l.colors=i}return l.positions=h,l.indices=s.faces,l.applyToMesh(e),e}_parse(n,s,e,r){return w._ConvertPLYToSplat(e).then(async t=>{const a=[];switch(t.mode){case 0:{const o=new S("GaussianSplatting",null,s,this._loadingOptions.keepInRam);o._parentContainer=this._assetContainer,a.push(o),await o.updateDataAsync(t.data)}break;case 1:{const o=new L("PointCloud",1,s);if(w._BuildPointCloud(o,t.data))return Promise.all([o.buildMeshAsync()]).then(h=>(a.push(h[0]),a));o.dispose()}break;case 2:if(t.faces)a.push(w._BuildMesh(s,t));else throw new Error("PLY mesh doesn't contain face informations.");break;default:throw new Error("Unsupported Splat mode")}return new Promise(o=>{o(a)})})}loadAssetContainerAsync(n,s,e){const r=new R(n);return this._assetContainer=r,this.importMeshAsync(null,n,s,e).then(t=>(t.meshes.forEach(a=>r.meshes.push(a)),this._assetContainer=null,r)).catch(t=>{throw this._assetContainer=null,t})}loadAsync(n,s,e){return this.importMeshAsync(null,n,s,e).then(()=>{})}static _ConvertPLYToSplat(n){const s=new Uint8Array(n),e=new TextDecoder().decode(s.slice(0,1024*10)),r=`end_header
`,t=e.indexOf(r);if(t<0||!e)return new Promise(u=>{u({mode:0,data:n})});const a=parseInt(/element vertex (\d+)\n/.exec(e)[1]),o=/element face (\d+)\n/.exec(e);let h=0;o&&(h=parseInt(o[1]));const l=/element chunk (\d+)\n/.exec(e);let i=0;l&&(i=parseInt(l[1]));let c=0,m=0;const d={double:8,int:4,uint:4,float:4,short:2,ushort:2,uchar:1,list:0};let C;(function(u){u[u.Vertex=0]="Vertex",u[u.Chunk=1]="Chunk"})(C||(C={}));let g=1;const k=[],I=e.slice(0,t).split(`
`);for(const u of I)if(u.startsWith("property ")){const[,f,x]=u.split(" ");g==1?m+=d[f]:g==0&&(k.push({name:x,type:f,offset:c}),c+=d[f]),d[f]||T.Warn(`Unsupported property type: ${f}.`)}else if(u.startsWith("element ")){const[,f]=u.split(" ");f=="chunk"?g=1:f=="vertex"&&(g=0)}const U=c,D=m;return S.ConvertPLYToSplatAsync(n).then(u=>{const f=new DataView(n,t+r.length);let x=D*i+U*a;const A=[];if(h)for(let p=0;p<h;p++){const _=f.getUint8(x);if(_==3){x+=1;for(let M=0;M<_;M++){const G=f.getUint32(x+(2-M)*4,!0);A.push(G)}x+=12}}if(i)return new Promise(p=>{p({mode:0,data:u,faces:A,hasVertexColors:!1})});let v=0,P=0;const V=["x","y","z","scale_0","scale_1","scale_2","opacity","rot_0","rot_1","rot_2","rot_3"],O=["red","green","blue","f_dc_0","f_dc_1","f_dc_2"];for(let p=0;p<k.length;p++){const _=k[p];V.includes(_.name)&&v++,O.includes(_.name)&&P++}const E=v==V.length&&P==3,z=h?2:E?0:1;return new Promise(p=>{p({mode:z,data:u,faces:A,hasVertexColors:!!P})})})}}w._DefaultLoadingOptions={keepInRam:!1};j(new w);export{w as SPLATFileLoader};
